// System Design Building Blocks:

// 𝟭. 𝗗𝗮𝘁𝗮𝗯𝗮𝘀𝗲𝘀: https://lnkd.in/gti8gjpz

// 𝟮. 𝗛𝗼𝗿𝗶𝘇𝗼𝗻𝘁𝗮𝗹 𝘃𝘀 𝗩𝗲𝗿𝘁𝗶𝗰𝗮𝗹 𝗦𝗰𝗮𝗹𝗶𝗻𝗴: https://lnkd.in/gAH2e9du

// 𝟯. 𝗖𝗮𝗰𝗵𝗶𝗻𝗴: https://lnkd.in/gC9piQbJ

// 𝟰. 𝗗𝗶𝘀𝘁𝗿𝗶𝗯𝘂𝘁𝗲𝗱 𝗖𝗮𝗰𝗵𝗶𝗻𝗴: https://lnkd.in/g7WKydNg

// 𝟱. 𝗟𝗼𝗮𝗱 𝗕𝗮𝗹𝗮𝗻𝗰𝗶𝗻𝗴: https://lnkd.in/gQaa8sXK

// 𝟲. 𝗦𝗤𝗟 𝘃𝘀 𝗡𝗼𝗦𝗤𝗟: https://lnkd.in/g3WC_yxn

// 𝟳. 𝗗𝗮𝘁𝗮𝗯𝗮𝘀𝗲 𝗦𝗰𝗮𝗹𝗶𝗻𝗴: https://lnkd.in/gAXpSyWQ

// 𝟴. 𝗗𝗮𝘁𝗮 𝗥𝗲𝗽𝗹𝗶𝗰𝗮𝘁𝗶𝗼𝗻: https://lnkd.in/gVAJxTpS

// 𝟵. 𝗗𝗮𝘁𝗮 𝗥𝗲𝗱𝘂𝗻𝗱𝗮𝗻𝗰𝘆: https://lnkd.in/gNN7TF7n

// 𝟭𝟬. 𝗗𝗮𝘁𝗮𝗯𝗮𝘀𝗲 𝗦𝗵𝗮𝗿𝗱𝗶𝗻𝗴: https://lnkd.in/gMqqc6x9

// 𝟭𝟭. 𝗗𝗮𝘁𝗮𝗯𝗮𝘀𝗲 𝗜𝗻𝗱𝗲𝘅'𝘀: https://lnkd.in/gCeshYVt

// 𝟭𝟮. 𝗣𝗿𝗼𝘅𝘆 𝗦𝗲𝗿𝘃𝗲𝗿: https://lnkd.in/gi8KnKS6 

// 𝟭𝟯. 𝗪𝗲𝗯𝗦𝗼𝗰𝗸𝗲𝘁: https://lnkd.in/g76Gv2KQ

// 𝟭𝟰. 𝗔𝗣𝗜 𝗚𝗮𝘁𝗲𝘄𝗮𝘆: https://lnkd.in/gnsJGJaM

// 𝟭𝟱. 𝗠𝗲𝘀𝘀𝗮𝗴𝗲 𝗤𝘂𝗲𝘂𝗲𝘀: https://lnkd.in/gTzY6uk8



// 30 Golden Tips to Ace your next System Design Interview:

// 1. Understand the functional and non-functional requirements before designing.
// 2. Clearly define the use cases and constraints of the system.
// 3. There is no perfect solution. It’s all about tradeoffs.
// 4. Design the system to be flexible.
// 5. Assume everything can and will fail. Make it fault tolerant.
// 6. Avoid over-engineering.
// 7. Design your system for scalability from the ground up.
// 8. Prefer horizontal scaling over vertical scaling for scalability.
// 9. Use Load Balancers to ensure high availability and distribute traffic.
// 10. Consider using SQL Databases for structured data and ACID transactions.
// 11. Opt for NoSQL Databases when dealing with unstructured data.
// 12. Consider using a graph database for highly connected data.
// 13. Use Database Sharding to scale SQL databases horizontally.
// 14. Use Database Indexing and search engines for efficient data retrievals.
// 15. Use Rate Limiting to prevent system overload and DOS attacks.
// 16. Use throttling to manage resource allocation dynamically.
// 17. Use WebSockets for real-time communication.
// 18. Use Heartbeat Mechanisms to detect failures.
// 19. Consider using a message queue for asynchronous communication.
// 20. Implement data partitioning and sharding for large datasets.
// 21. Consider denormalizing databases for read-heavy workloads.
// 22. Consider event-driven architecture for decoupled systems.
// 23. Use bloom filters to check for an item in a large dataset quickly.
// 24. Use CDNs to reduce latency for a global user base.
// 25. Add a caching layer to reduce database load and improve response times.
// 26. Use write-through cache for write-heavy applications.
// 27. Use read-through cache for read-heavy applications.
// 28. Use object storage like S3 for storing large datasets and media files.
// 29. Implement Data Replication and Redundancy to avoid single point of failure.
// 30. Implement Autoscaling to handle traffic spikes smoothly.