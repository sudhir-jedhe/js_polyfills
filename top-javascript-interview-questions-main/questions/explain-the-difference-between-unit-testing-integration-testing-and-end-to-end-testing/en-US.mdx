---
title: Explain the difference between unit testing, integration testing, and end-to-end testing
---

## TL;DR

Unit testing focuses on testing individual components or functions in isolation to ensure they work as expected. Integration testing checks how different modules or services work together. End-to-end testing simulates real user scenarios to verify the entire application flow from start to finish.

---

## Difference between unit testing, integration testing, and end-to-end testing

### Unit testing

Unit testing involves testing individual components or functions in isolation. The goal is to ensure that each part of the code works correctly on its own. These tests are usually written by developers and are the first line of defense against bugs.

- **Scope**: Single function or component
- **Tools**: Jest, Mocha, Jasmine
- **Example**: Testing a function that adds two numbers

```js
function add(a, b) {
  return a + b;
}

test('adds 1 + 2 to equal 3', () => {
  expect(add(1, 2)).toBe(3);
});
```

### Integration testing

Integration testing focuses on verifying the interactions between different modules or services. The goal is to ensure that combined parts of the application work together as expected. These tests are usually more complex than unit tests and may involve multiple components.

- **Scope**: Multiple components or services
- **Tools**: Jest, Mocha, Jasmine, Postman (for API testing)
- **Example**: Testing a function that fetches data from an API and processes it

```js
async function fetchData(apiUrl) {
  const response = await fetch(apiUrl);
  const data = await response.json();
  return processData(data);
}

test('fetches and processes data correctly', async () => {
  const apiUrl = 'https://api.example.com/data';
  const data = await fetchData(apiUrl);
  expect(data).toEqual(expectedProcessedData);
});
```

### End-to-end testing

End-to-end (E2E) testing simulates real user scenarios to verify the entire application flow from start to finish. The goal is to ensure that the application works as a whole, including the user interface, backend, and any external services.

- **Scope**: Entire application
- **Tools**: Cypress, Selenium, Puppeteer
- **Example**: Testing a user login flow

```js
describe('User Login Flow', () => {
  it('should allow a user to log in', () => {
    cy.visit('https://example.com/login');
    cy.get('input[name="username"]').type('testuser');
    cy.get('input[name="password"]').type('password123');
    cy.get('button[type="submit"]').click();
    cy.url().should('include', '/dashboard');
  });
});
```

## Further reading

- [Unit testing on Wikipedia](https://en.wikipedia.org/wiki/Unit_testing)
- [Integration testing on Wikipedia](https://en.wikipedia.org/wiki/Integration_testing)
- [End-to-end testing on Wikipedia](https://en.wikipedia.org/wiki/End-to-end_testing)
- [Jest documentation](https://jestjs.io/docs/getting-started)
- [Cypress documentation](https://docs.cypress.io/guides/overview/why-cypress)
