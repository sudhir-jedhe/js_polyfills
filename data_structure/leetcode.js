// DSA was extremely HARD

// https://leetcode.com/discuss/study-guide/1688903/Solved-all-two-pointers-problems-in-100-days


// 1. Sliding window pattern.
// 2. Two pointer pattern.
// 3. Fast & slow pointers pattern.
// 4. Merger interval pattern.
// 5. Cyclic sort pattern.
// 6. In-place reversal of linked list pattern.
// 7. Tree breadth first search pattern.
// 8. Depth first search DFS pattern.
// 9. Two heap pattern.
// 10. Subsets pattern.
// 11. Modified binary search pattern.
// 12. Bitwise xor pattern.
// 13. Top 'K' elements pattern.
// 14. K-way merge pattern.
// 15. 0/1 knapsack DP pattern.
// 16. Topological sort Graph pattern.

// Until I found these 14 Problem Solving Patterns⚡

// 1. Two Pointer Problems:
// https://lnkd.in/dK_fB-Eg

// 2. Backtracking Pattern:
// https://lnkd.in/dDGsdfps

// 3. Dynamic Programming Patterns:
// https://lnkd.in/dX7a4cau

// 4. Dynamic Programming Patterns 2:
// https://lnkd.in/db2tAp27

// 5. Powerful Ultimate Binary Search Template:
// https://lnkd.in/dxk7kdeb

// 6. A general approach to backtracking questions:
// https://lnkd.in/drsHxsZh

// 7. Binary Tree Traversal & Views:
// https://lnkd.in/dxGcKx65

// 8. Graph For Beginners [Problems | Pattern | Sample Solutions]:
// https://lnkd.in/dkpyiB3R

// 9. A comprehensive guide and template for monotonic stack based problems:
// https://lnkd.in/dtmFMzDJ

// 10. All Types of Patterns for Bits Manipulations and How to use it:
// https://lnkd.in/d-rfVNx2

// 11. Collections of Important String questions Pattern:
// https://lnkd.in/dCy_j-vw

// 12. Leetcode Pattern 1 | BFS + DFS == 25% of the problems:
// https://lnkd.in/dtaEpzrC

// 13. Template that can solve most 'substring' problems:
// https://lnkd.in/dEbVbBu4

// 14. C++ Maximum Sliding Window Cheat sheet Template:
// https://lnkd.in/dPiMzzpA



// 1. Number of Islands - https://lnkd.in/dHQJGhPJ
// 2. k Jumps on Grid - https://lnkd.in/dKM_ETsM)
// 3. Finding Prefix in Dictionary - https://lnkd.in/dpRvFDq5
// 4. Binary Tree Top-Down View - https://lnkd.in/dmun-Pn3
// 5. Diameter of a binary tree [Path is needed] - https://lnkd.in/dH-w_DQV
// 6. Contains Duplicates III - https://lnkd.in/djcWHTaX
// 7. Minimum Window Substring [Variation of this question] - https://lnkd.in/dPfnQZmr
// 8. Split String - https://lnkd.in/eTb6VDmC
// 9. Bin packing problem - https://lnkd.in/eXZKX3Sv
// 10. Sum of smallest elements in distinct sets - https://lnkd.in/exm7jDTm
// 11. Kth Step Sequence - https://lnkd.in/ertBsik7
// 12. Collecting coins [Combinatorics involved] - https://lnkd.in/eqM-zDyi
// 13. Turn on all systems [Minimum spanning tree] - https://lnkd.in/ekj627TZ
// 14. Turning Pages [DFS / Backtracking] - https://lnkd.in/eHsfBsM5
// 15. Delete Edge to minimize the difference in subtree sum - https://lnkd.in/edba9e8T
// 16. Queries on Binary String [Queues can be used] - https://lnkd.in/edZRjGck
// 17. Insert Delete Get Random - https://lnkd.in/eRk-hSKW
// 18. Implement a queue with two stacks - https://lnkd.in/ebJbDced
// 19. Index of a rotation point in an array - https://lnkd.in/e2KQs-Mq
// 20. Implement a hash map - https://lnkd.in/eznHKki3

// I have already shared 80 DSA questions according to the topics
// - Part 1 : https://lnkd.in/da5w-x4b
// - Part 2 : https://lnkd.in/ddPa2gvZ


// 𝗗𝘆𝗻𝗮𝗺𝗶𝗰 𝗣𝗿𝗼𝗴𝗿𝗮𝗺𝗺𝗶𝗻𝗴 (𝗗𝗣):
// 1. How do you find the nth Fibonacci number using dynamic programming?
// 2. Write a dynamic programming solution for the 0/1 knapsack problem.
// 3. Memoization to optimize recursive solutions in dynamic programming?
// 4. Implement a dynamic programming algorithm to find the longest common subsequence of two strings.
// 5. The coin change problem.
// 6. Tabulation approach in dynamic programming.

// 𝗕𝗮𝗰𝗸𝘁𝗿𝗮𝗰𝗸𝗶𝗻𝗴:
// 7. Backtracking algorithm to solve the N-Queens problem.
// 8. Generate all permutations of a given set using backtracking?
// 9. Implement backtracking to solve the Sudoku puzzle.
// 10. Subset sum problem.
// 11. Graph coloring problem using backtracking.
// 12. Write a backtracking algorithm to find the Hamiltonian cycle in a graph.

// 𝗛𝗮𝘀𝗵𝗶𝗻𝗴:
// 13. Implement a hash table using separate chaining.
// 14. First non-repeating character in a string using hashing.
// 15. Collision resolution techniques in hashing.
// 16. Write a function to solve the two-sum problem using hashing.
// 17. How can you implement a hash set data structure?
// 18. Count the frequency of elements in an array using hashing.

// 𝗛𝗲𝗮𝗽:
// 19. Implement a priority queue using a min-heap.
// 20. How do you merge K sorted arrays using a min-heap?
// 21. Write a function to perform heap sort algorithm.
// 22. Find the kth largest element in an array using a min-heap.
// 23. Implement a priority queue using a min-heap.
// 24. How do you build a max heap from an array?

// 𝗧𝗿𝗶𝗲𝘀:
// 25. Implement a trie data structure.
// 26. Write a function to search for a word in a trie.
// 27. How can you implement autocomplete feature using a trie?
// 28. Deleting a word from a trie.
// 30. Write a function to find all words matching a pattern in a trie.

// 𝗚𝗿𝗲𝗲𝗱𝘆 𝗔𝗹𝗴𝗼𝗿𝗶𝘁𝗵𝗺𝘀:
// 31. Solve the activity selection problem using a greedy algorithm.
// 32. Implement Huffman coding using a greedy algorithm.
// 33. Write a function to find the minimum spanning tree using Prim's algorithm.
// 34. Coin change problem.
// 35. Dijkstra's algorithm using a greedy approach.
// 36. Implement the job sequencing problem using a greedy algorithm.


// 37. Stack Vs queue.
// 38. breadth-first search (BFS) and depth-first search (DFS) traversal 
// 39. Concept of big O notation.
// 40. What is an AVL tree? Explain its properties and how it maintains balance during insertion and deletion operation